#pragma once

#include <glob.h>

#include "ackermann_msgs/msg/ackermann_drive.hpp"
#include "nav_msgs/msg/odometry.hpp"
#include "optional"
#include "phnx_io_ros/pid_interface.hpp"
#include "phnx_io_ros/serial.hpp"
#include "phnx_io_ros/vendor/concurrentqueue.h"
#include "rclcpp/logger.hpp"
#include "rclcpp/rclcpp.hpp"
#include "robot_state_msgs/srv/set_state.hpp"

namespace pir {

enum CanMappings : uint32_t {
    KillAuton = 0x0,
    SetBrake = 0x1,
    LockBrake = 0x2,
    UnlockBrake = 0x3,
    SetAngle = 0x4,
    GetAngle = 0x5,
    SetThrottle = 0x6,
    EncoderTick = 0x7,
    TrainingMode = 0x8,
};

/// Contains the device name as well as the serial object that acts as that device's handler for IO
/// This allows for multiple connected teensy devices to be handled in the future.
struct device_info {
    std::string port_name;
    serial::serial* handler;
};

class PhnxIoRos : public rclcpp::Node {
public:
    explicit PhnxIoRos(rclcpp::NodeOptions options);

    ///@breif Reads data of size serial::message from connected port
    void read_data(serial::message m);

    ~PhnxIoRos() override;

    void filtered_odom_cb(nav_msgs::msg::Odometry::ConstSharedPtr msg);

private:
    /// Command topic
    rclcpp::Subscription<ackermann_msgs::msg::AckermannDrive>::SharedPtr _acks_sub;
    /// Filtered odom for use in controls
    rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr _filtered_odom_sub;
    /// Odometry from CAN bus sensors, like encoders
    rclcpp::Publisher<nav_msgs::msg::Odometry>::SharedPtr _odom_pub;
    /// Connection to the robot state server, to allow for estopping
    rclcpp::Client<robot_state_msgs::srv::SetState>::SharedPtr _robot_state_client;

    /// PID controller
    std::unique_ptr<PidInterface> pid;

    // Serial port params
    std::string _port_pattern{};
    std::list<serial::enc_msg> enc_msgs;
    long _baud_rate{};
    device_info cur_device;
    int FAILURE_TOLERANCE{5};

    ///@brief Convert ackermann messages into CAN messages and send them to the
    /// CAN bus
    ///@param msg Ackermann drive message to convert
    void send_can_cb(ackermann_msgs::msg::AckermannDrive::SharedPtr msg);

    ///@brief Closes open serial connection
    void close();

    ///@brief Attempts to find devices given a certain pattern.
    int find_devices();

    ///@brief Applies a control generated by PID.
    void handle_pid_update(std::tuple<double, phnx_control::SpeedController::Actuator> control);
};

}  // namespace pir